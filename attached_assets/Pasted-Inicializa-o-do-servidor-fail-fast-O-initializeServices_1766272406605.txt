Inicialização do servidor é “fail-fast”
O initializeServices roda em Promise.race com timeout de 30s; qualquer falha (auth, registro de rotas, etc.) faz o processo chamar process.exit(1). Em produção um env ou credencial faltante derruba o pod/instância imediatamente. 

Em produção o app também tenta servir estáticos de dist/public. Se o build do cliente não for executado ou não for publicado nesse caminho, as rotas catch-all 404 podem aparecer. 

Dependências de infraestrutura obrigatórias
Schedulers sobem automaticamente (polling worker + vacuum + arquivamento). Se DISABLE_SCHEDULERS não estiver setado, é preciso ter banco acessível e permissões de VACUUM; caso contrário a inicialização ou os jobs podem falhar e manter o processo em erro. 

O serviço de arquivamento depende de:

PRIVATE_OBJECT_DIR apontando para bucket/objeto (usado para montar o path), caso contrário lança erro. 

Cliente de object storage configurado (credenciais GCS) e permissões de upload/delete; falhas interrompem o job e deixam status “partial”. 

Permissão de deletar dados e rodar VACUUM nas tabelas arquivadas. 

Rotas e autenticação de ingestão
Os endpoints /api/events/ingest e /api/events/ingest/batch exigem header X-API-Key válido e aplicam rate-limit. Sem chave ou com limites excedidos, retornam 401/403/429 — se o front ou integradores não lidarem, parecerá “deploy quebrado”. 

O ingress batch valida até 100 eventos por requisição; cargas maiores serão rejeitadas com 400. 

Possíveis gargalos de long-running
Jobs longos (sync Zendesk, arquivamento) rodam dentro do processo web; em ambientes com timeouts de plataforma (ex.: containers reiniciados por inatividade), um restart no meio deixa jobs em estado “partial” e pode gerar retries custosos ou locks. 

Checklist rápido para evitar bloqueios
Definir PRIVATE_OBJECT_DIR, credenciais de object storage e variáveis de banco antes do deploy. 

Se o ambiente não deve rodar jobs, setar DISABLE_SCHEDULERS=true para subir só a API. 

Garantir build do front gerando dist/public antes de NODE_ENV=production. 

Provisionar permissões de VACUUM e deletar em todas as tabelas usadas por arquivamento. 

Criar e distribuir chaves de API para ingestão externa e ajustar limites conforme demanda. 




private async runVacuum(tableName: string): Promise<void> {
  try {
    console.log(`[Archive] Running VACUUM on ${tableName}...`);
    await db.execute(sql`VACUUM ${sql.identifier(tableName)}`);
    console.log(`[Archive] VACUUM completed on ${tableName}`);
 